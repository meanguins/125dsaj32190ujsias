<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Specificații Interactive & Ghid - Procesator Inteligent de CV-uri</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Chosen Palette: Calm Neutrals with Sky Blue Accent */
        /* Application Structure Plan: Single-page application with tab-based navigation (Prezentare Generală, Funcționalități, Schema de Extracție, Tehnologii, Configurare Sistem, Ghid Utilizare, Integrare Recruit CRM, Considerații). Content displayed dynamically. Interactive schema viewer. Data flow diagram visualization. Designed for easy understanding of the backend system's technical specifications, setup, usage, and specific CRM integration. */
        /* Visualization & Content Choices: Overview: Text, HTML/CSS data flow diagram. Features: Clickable text sections. Data Schema: Interactive nested list for CV_EXTRACTION_SCHEMA. Tech Stack: List. Considerations: Expandable text. Setup & Usage & Recruit CRM: Detailed step-by-step text, code blocks for examples. No Chart.js/Plotly as report is spec, not data. Focus on HTML/CSS for visuals. NO SVG/Mermaid. */
        /* CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. */
        body {
            font-family: 'Inter', sans-serif; 
            line-height: 1.6; 
        }
        .tab-active {
            border-bottom-width: 3px; 
            border-color: #0284c7; /* sky-600 */
            color: #0284c7; 
            font-weight: 600;
        }
        .tab-button {
             transition: color 0.2s ease-in-out, border-color 0.2s ease-in-out;
        }
        .content-section {
            display: none;
        }
        .content-section.active {
            display: block;
        }
        .schema-key {
            cursor: pointer;
            font-weight: 500;
            transition: color 0.2s ease;
        }
        .schema-key:hover {
            color: #0ea5e9; /* sky-500 */
        }
        .schema-details {
            display: none;
            padding-left: 1.5rem; 
            border-left: 2px solid #d1d5db; /* gray-300 */
            margin-left: 0.75rem; /* ml-3 */
            margin-top: 0.5rem; /* mt-2 */
        }
        .schema-details.open {
            display: block;
        }
        .flow-step {
            min-height: 90px; 
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: center; 
            padding: 1rem; 
        }
        .flow-step:hover {
            transform: translateY(-4px); 
            box-shadow: 0 6px 16px rgba(0,0,0,0.12); 
        }
        .flow-arrow {
            font-size: 1.75rem; 
            color: #0ea5e9; 
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 90px; 
        }
        .code-block {
            background-color: #1e293b; 
            color: #e2e8f0; 
            padding: 1.25rem; 
            border-radius: 0.5rem; 
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', Courier, monospace;
            font-size: 0.875rem; 
            line-height: 1.5rem; 
            margin-top: 0.75rem; 
            margin-bottom: 0.75rem; 
            border: 1px solid #334155; 
        }
        .code-block span.block {
            display: block; 
        }
        .expand-button {
            transition: color 0.2s ease;
        }
        .expand-button::after {
            content: ' ▼';
            font-size: 0.75em;
            margin-left: 6px;
            display: inline-block;
            transition: transform 0.2s ease;
        }
        .expand-button.open::after {
            transform: rotate(180deg);
            content: ' ▲'; 
        }
        .step-counter {
            background-color: #0284c7; 
            color: white;
            border-radius: 50%;
            width: 2.25rem; 
            height: 2.25rem; 
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 1rem; 
            flex-shrink: 0; 
        }
        h2.section-title { 
            font-size: 1.75rem; 
            font-weight: 700; 
            color: #0c4a6e; 
            margin-bottom: 1.5rem; 
            padding-bottom: 0.5rem; 
            border-bottom: 2px solid #e0f2fe; 
        }
        h3.step-title {
            display: flex;
            align-items: center;
            font-size: 1.5rem; 
            font-weight: 600; 
            color: #0369a1; 
            margin-bottom: 1rem; 
        }
         h4.sub-step-title {
            font-size: 1.125rem; 
            font-weight: 600; 
            color: #075985; 
            margin-top: 1.25rem; 
            margin-bottom: 0.75rem; 
        }
        .text-content p, .text-content ul, .text-content div > p, .text-content div > ul {
            margin-bottom: 1rem; 
            line-height: 1.7; 
        }
        .text-content ul {
            padding-left: 1.25rem; 
        }
        .text-content strong {
            color: #1e293b; 
        }
        .note {
            background-color: #e0f2fe; 
            border-left: 4px solid #0ea5e9; 
            padding: 1rem;
            margin-top: 1rem; 
            margin-bottom: 1.5rem; 
            border-radius: 0.375rem; 
        }
        .note p {
            margin-bottom: 0.25rem;
            color: #0c4a6e; 
        }
        .note p.font-semibold {
            color: #0369a1; 
        }
        .warning-note {
            background-color: #fef9c3; 
            border-left: 4px solid #f59e0b; 
            padding: 1rem;
            margin-top: 1rem;
            margin-bottom: 1.5rem;
            border-radius: 0.375rem;
        }
        .warning-note p {
             color: #78350f; 
        }
         .warning-note p.font-semibold {
            color: #b45309; 
        }
         .info-note {
            background-color: #f0f9ff; 
            border-left: 4px solid #0ea5e9; 
            padding: 1rem;
            margin-top: 1rem;
            margin-bottom: 1.5rem;
            border-radius: 0.375rem;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-slate-100 text-slate-700 antialiased">

    <header class="bg-sky-700 text-white shadow-lg sticky top-0 z-50">
        <div class="container mx-auto px-4 sm:px-6 lg:px-8 py-4">
            <h1 class="text-2xl sm:text-3xl font-bold text-center tracking-tight">Specificații Interactive & Ghid - Procesator Inteligent de CV-uri</h1>
        </div>
    </header>

    <nav class="bg-white shadow-md sticky top-[68px] sm:top-[76px] z-40">
        <div class="container mx-auto px-4 sm:px-6 lg:px-8">
            <ul class="flex flex-wrap justify-center sm:justify-start -mb-px">
                <li><button class="tab-button inline-block py-3 px-3 sm:py-4 sm:px-4 text-sm sm:text-base text-slate-600 hover:text-sky-600 hover:border-sky-500" data-tab="overview">Prezentare Generală</button></li>
                <li><button class="tab-button inline-block py-3 px-3 sm:py-4 sm:px-4 text-sm sm:text-base text-slate-600 hover:text-sky-600 hover:border-sky-500" data-tab="features">Funcționalități</button></li>
                <li><button class="tab-button inline-block py-3 px-3 sm:py-4 sm:px-4 text-sm sm:text-base text-slate-600 hover:text-sky-600 hover:border-sky-500" data-tab="schema">Schema de Extracție</button></li>
                <li><button class="tab-button inline-block py-3 px-3 sm:py-4 sm:px-4 text-sm sm:text-base text-slate-600 hover:text-sky-600 hover:border-sky-500" data-tab="tech">Tehnologii</button></li>
                <li><button class="tab-button inline-block py-3 px-3 sm:py-4 sm:px-4 text-sm sm:text-base text-slate-600 hover:text-sky-600 hover:border-sky-500" data-tab="setup">Configurare Sistem</button></li>
                <li><button class="tab-button inline-block py-3 px-3 sm:py-4 sm:px-4 text-sm sm:text-base text-slate-600 hover:text-sky-600 hover:border-sky-500" data-tab="usage">Ghid Utilizare API</button></li>
                <li><button class="tab-button inline-block py-3 px-3 sm:py-4 sm:px-4 text-sm sm:text-base text-slate-600 hover:text-sky-600 hover:border-sky-500" data-tab="recruitcrm">Integrare Recruit CRM</button></li>
                <li><button class="tab-button inline-block py-3 px-3 sm:py-4 sm:px-4 text-sm sm:text-base text-slate-600 hover:text-sky-600 hover:border-sky-500" data-tab="considerations">Considerații</button></li>
            </ul>
        </div>
    </nav>

    <main class="container mx-auto p-4 sm:p-6 lg:p-8 mt-6">
        <section id="overview" class="content-section bg-white p-6 sm:p-8 rounded-lg shadow-xl">
            <h2 class="section-title">Prezentare Generală a Sistemului</h2>
            <div class="text-content">
                <p>
                    Această aplicație interactivă vă ghidează prin specificațiile tehnice, configurarea și utilizarea sistemului nostru avansat de procesare automată a CV-urilor. Sistemul este conceput ca o soluție robustă și scalabilă, menită să eficientizeze extragerea informațiilor structurate din CV-uri, utilizând cele mai noi tehnologii de inteligență artificială.
                </p>
                <div class="mb-8">
                    <h3 class="text-xl font-semibold text-sky-700 mb-3">Arhitectura Sistemului și Tehnologii Cheie</h3>
                    <p class="mb-3">Sistemul este construit ca o aplicație web FastAPI, containerizată cu Docker și optimizată pentru implementare pe platforme serverless precum Google Cloud Run.</p>
                    <ul class="list-disc list-inside space-y-2">
                        <li><strong class="font-medium">API Backend:</strong> Dezvoltat în Python folosind framework-ul FastAPI.</li>
                        <li><strong class="font-medium">Inteligență Artificială Generativă:</strong> Utilizează modelul `gemini-2.5-flash-preview-05-20` de la Google, accesat prin SDK-ul `google-genai`.</li>
                        <li><strong class="font-medium">Bază de Date NoSQL:</strong> Google Cloud Firestore în modul Nativ.</li>
                        <li><strong class="font-medium">Platformă de Rulare (Recomandată):</strong> Google Cloud Run.</li>
                        <li><strong class="font-medium">Containerizare:</strong> Docker.</li>
                    </ul>
                </div>

                <div>
                    <h3 class="text-xl font-semibold text-sky-700 mb-4">Fluxul de Date (End-to-End)</h3>
                    <p class="mb-6">Următoarea diagramă ilustrează pașii principali în procesarea unui CV, de la primirea acestuia până la stocarea datelor extrase.</p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-5 gap-4 items-stretch mb-4">
                        <div class="flow-step bg-sky-50 p-4 rounded-lg shadow text-center">
                            <span class="text-3xl mb-2">📥</span>
                            <h4 class="font-semibold text-sky-700 text-base">1. Primire Webhook</h4>
                            <p class="text-xs text-slate-600">Sistem extern trimite CV (text/URL) și metadate.</p>
                        </div>
                        <div class="flow-arrow hidden md:flex">➔</div>
                        <div class="flow-step bg-sky-50 p-4 rounded-lg shadow text-center">
                            <span class="text-3xl mb-2">🛡️</span>
                            <h4 class="font-semibold text-sky-700 text-base">2. Validare & Idempotență</h4>
                            <p class="text-xs text-slate-600">Verificare secret webhook și evitare duplicate.</p>
                        </div>
                        <div class="flow-arrow hidden md:flex">➔</div>
                        <div class="flow-step bg-sky-50 p-4 rounded-lg shadow text-center">
                            <span class="text-3xl mb-2">⚙️</span>
                            <h4 class="font-semibold text-sky-700 text-base">3. Procesare Asincronă</h4>
                            <p class="text-xs text-slate-600">Răspuns HTTP 202; procesarea continuă în fundal.</p>
                        </div>
                    </div>
                    
                    <div class="flex justify-center my-3 md:my-4"><span class="flow-arrow transform md:rotate-0 rotate-90">⬇️</span></div>
                    
                    <div class="grid grid-cols-1 md:grid-cols-5 gap-4 items-stretch mb-4">
                        <div class="flow-step bg-teal-50 p-4 rounded-lg shadow text-center">
                            <span class="text-3xl mb-2">📄</span>
                            <h4 class="font-semibold text-teal-700 text-base">4. Descărcare & Parsare (URL)</h4>
                            <p class="text-xs text-slate-600">Descărcare asincronă și extragere text din PDF/DOCX.</p>
                        </div>
                        <div class="flow-arrow hidden md:flex">➔</div>
                        <div class="flow-step bg-teal-50 p-4 rounded-lg shadow text-center">
                            <span class="text-3xl mb-2">🧠</span>
                            <h4 class="font-semibold text-teal-700 text-base">5. Extragere Date (Gemini)</h4>
                            <p class="text-xs text-slate-600">Modelul AI extrage informații structurate conform schemei.</p>
                        </div>
                        <div class="flow-arrow hidden md:flex">➔</div>
                        <div class="flow-step bg-teal-50 p-4 rounded-lg shadow text-center">
                            <span class="text-3xl mb-2">💾</span>
                            <h4 class="font-semibold text-teal-700 text-base">6. Persistență (Firestore)</h4>
                            <p class="text-xs text-slate-600">Salvare date inițiale, status, și date extrase.</p>
                        </div>
                    </div>

                    <div class="flex justify-center my-3 md:my-4"><span class="flow-arrow transform md:rotate-0 rotate-90">⬇️</span></div>
                    
                    <div class="flow-step bg-indigo-50 p-4 rounded-lg shadow text-center max-w-md mx-auto">
                        <span class="text-3xl mb-2">📊</span>
                        <h4 class="font-semibold text-indigo-700 text-base">7. Verificare Status (Opțional)</h4>
                        <p class="text-xs text-slate-600">Clientul poate interoga un endpoint pentru a vedea starea procesării.</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="features" class="content-section bg-white p-6 sm:p-8 rounded-lg shadow-xl">
            <h2 class="section-title">Funcționalități Detaliate</h2>
            <div class="text-content">
                <p class="mb-8">
                    Sistemul nostru include o serie de funcționalități avansate pentru a asigura o procesare eficientă, sigură și fiabilă a CV-urilor. Fiecare componentă a fost proiectată cu atenție la detalii pentru a oferi o experiență optimă. Click pe fiecare titlu pentru a expanda detaliile.
                </p>
            </div>
            <div class="space-y-6">
                <div>
                    <h3 class="text-xl font-semibold text-sky-600 mb-2 expand-button cursor-pointer" onclick="toggleDetails(this, 'feature-webhook')">Endpoint Webhook (`/webhook/cv`)</h3>
                    <div id="feature-webhook" class="schema-details ml-0 pl-0 border-l-0 text-content">
                        <p><strong class="font-medium">Metodă HTTP:</strong> POST</p>
                        <p><strong class="font-medium">Securizare:</strong> Validare prin header `X-Webhook-Secret`.</p>
                        <p><strong class="font-medium">Payload Intrare:</strong> CV (text/URL), `source_candidate_id`, `idempotency_key`, `metadata`.</p>
                        <p><strong class="font-medium">Răspuns:</strong> HTTP 202 Accepted, `processing_id`, `status`, `status_url`.</p>
                        <p>Comportament: Validează, verifică idempotența, inițiază procesare asincronă.</p>
                    </div>
                </div>
                <div>
                    <h3 class="text-xl font-semibold text-sky-600 mb-2 expand-button cursor-pointer" onclick="toggleDetails(this, 'feature-url-processing')">Procesarea Fișierelor CV de la URL</h3>
                     <div id="feature-url-processing" class="schema-details ml-0 pl-0 border-l-0 text-content">
                        <p><strong class="font-medium">Biblioteci:</strong> `aiohttp`, `PyPDF2`, `python-docx`.</p>
                        <p>Descărcare asincronă, User-Agent generic, detecție MIME.</p>
                        <p>Gestionare robustă a erorilor de rețea și parsare.</p>
                    </div>
                </div>
                 <div>
                    <h3 class="text-xl font-semibold text-sky-600 mb-2 expand-button cursor-pointer" onclick="toggleDetails(this, 'feature-gemini')">Integrarea cu API-ul Gemini</h3>
                     <div id="feature-gemini" class="schema-details ml-0 pl-0 border-l-0 text-content">
                        <p><strong class="font-medium">SDK:</strong> `google-genai`.</p>
                        <p><strong class="font-medium">Model:</strong> `gemini-2.5-flash-preview-05-20`.</p>
                        <p><strong class="font-medium">Configurație:</strong> `response_mime_type: "application/json"`, `response_schema`, `temperature: 0.1`, `safety_settings: BLOCK_NONE`, `thinking_config: thinking_budget=0`.</p>
                        <p>Prompt în engleză, apel asincron, reîncercări automate.</p>
                    </div>
                </div>
                <div>
                    <h3 class="text-xl font-semibold text-sky-600 mb-2 expand-button cursor-pointer" onclick="toggleDetails(this, 'feature-firestore')">Persistența Datelor în Firestore</h3>
                     <div id="feature-firestore" class="schema-details ml-0 pl-0 border-l-0 text-content">
                        <p><strong class="font-medium">SDK:</strong> `firebase-admin`.</p>
                        <p><strong class="font-medium">Structura Colecției:</strong> `artifacts/{APP_ID}/users/cv_processing_service_user/processed_cvs`.</p>
                        <p>Stochează: `processing_id`, payload, status, date extrase, erori, timestamps, etc.</p>
                    </div>
                </div>
                 <div>
                    <h3 class="text-xl font-semibold text-sky-600 mb-2 expand-button cursor-pointer" onclick="toggleDetails(this, 'feature-status')">Endpoint de Status</h3>
                     <div id="feature-status" class="schema-details ml-0 pl-0 border-l-0 text-content">
                        <p><strong class="font-medium">Metodă HTTP:</strong> GET, `/status/cv/{processing_id}`.</p>
                        <p>Returnează starea curentă și rezultatele unei procesări.</p>
                    </div>
                </div>
                <div>
                    <h3 class="text-xl font-semibold text-sky-600 mb-2 expand-button cursor-pointer" onclick="toggleDetails(this, 'feature-idempotency')">Gestionarea Idempotenței</h3>
                     <div id="feature-idempotency" class="schema-details ml-0 pl-0 border-l-0 text-content">
                        <p>Previne procesările duplicate bazate pe `idempotency_key` sau `source_candidate_id`.</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="schema" class="content-section bg-white p-6 sm:p-8 rounded-lg shadow-xl">
            <h2 class="section-title">Schema de Extracție a Datelor (`CV_EXTRACTION_SCHEMA`)</h2>
            <div class="text-content">
                <p class="mb-8">
                    Aceasta este structura JSON detaliată pe care modelul Gemini o utilizează pentru a extrage și organiza informațiile din CV-uri. Puteți da click pe fiecare cheie principală pentru a vedea sub-proprietățile și descrierile acestora. Câmpurile marcate cu "(obligatoriu)" în descrierea schemei din codul sursă sunt esențiale pentru structura de bază a datelor extrase.
                </p>
            </div>
            <div id="cvSchemaContainer" class="space-y-3">
                </div>
        </section>

        <section id="tech" class="content-section bg-white p-6 sm:p-8 rounded-lg shadow-xl">
            <h2 class="section-title">Tehnologii Utilizate</h2>
            <div class="text-content">
                <p class="mb-8">
                    Sistemul se bazează pe un set de tehnologii moderne și performante pentru a asigura eficiență și fiabilitate.
                </p>
            </div>
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                <div class="bg-slate-50 p-5 rounded-lg shadow hover:shadow-lg transition-shadow">
                    <h3 class="text-lg font-semibold text-sky-700 mb-1">Python & FastAPI</h3>
                    <p class="text-sm text-slate-600">Pentru dezvoltarea rapidă și performantă a API-ului backend.</p>
                </div>
                <div class="bg-slate-50 p-5 rounded-lg shadow hover:shadow-lg transition-shadow">
                    <h3 class="text-lg font-semibold text-sky-700 mb-1">Google Gemini 2.5 Flash</h3>
                    <p class="text-sm text-slate-600">Model AI de ultimă generație pentru extragerea inteligentă a datelor (via SDK `google-genai`).</p>
                </div>
                <div class="bg-slate-50 p-5 rounded-lg shadow hover:shadow-lg transition-shadow">
                    <h3 class="text-lg font-semibold text-sky-700 mb-1">Google Cloud Firestore</h3>
                    <p class="text-sm text-slate-600">Bază de date NoSQL scalabilă pentru stocarea datelor.</p>
                </div>
                <div class="bg-slate-50 p-5 rounded-lg shadow hover:shadow-lg transition-shadow">
                    <h3 class="text-lg font-semibold text-sky-700 mb-1">Google Cloud Run</h3>
                    <p class="text-sm text-slate-600">Platformă serverless pentru implementare și scalare automată.</p>
                </div>
                <div class="bg-slate-50 p-5 rounded-lg shadow hover:shadow-lg transition-shadow">
                    <h3 class="text-lg font-semibold text-sky-700 mb-1">Docker</h3>
                    <p class="text-sm text-slate-600">Pentru containerizarea aplicației, asigurând portabilitate.</p>
                </div>
                <div class="bg-slate-50 p-5 rounded-lg shadow hover:shadow-lg transition-shadow">
                    <h3 class="text-lg font-semibold text-sky-700 mb-1">aiohttp, PyPDF2, python-docx</h3>
                    <p class="text-sm text-slate-600">Pentru procesarea asincronă a fișierelor și extragerea textului.</p>
                </div>
                 <div class="bg-slate-50 p-5 rounded-lg shadow hover:shadow-lg transition-shadow">
                    <h3 class="text-lg font-semibold text-sky-700 mb-1">Pydantic</h3>
                    <p class="text-sm text-slate-600">Pentru validarea datelor și definirea modelelor.</p>
                </div>
                 <div class="bg-slate-50 p-5 rounded-lg shadow hover:shadow-lg transition-shadow">
                    <h3 class="text-lg font-semibold text-sky-700 mb-1">Tenacity</h3>
                    <p class="text-sm text-slate-600">Pentru implementarea logicii de reîncercare robustă.</p>
                </div>
            </div>
        </section>

        <section id="setup" class="content-section bg-white p-6 sm:p-8 rounded-lg shadow-xl">
            <h2 class="section-title">Ghid de Configurare a Sistemului (Setup)</h2>
            <div class="text-content">
                <p class="mb-8">
                    Urmați acești pași pentru a configura și rula local sistemul de procesare a CV-urilor. Acest ghid presupune că aveți deja cunoștințe de bază despre Python, terminal și Google Cloud Platform.
                </p>
            </div>

            <div class="space-y-8">
                <div>
                    <h3 class="step-title"><span class="step-counter">1</span>Cerințe Preliminare</h3>
                    <ul class="list-disc list-inside space-y-2 text-slate-700 ml-10">
                        <li>**Python 3.10+** instalat pe sistemul dumneavoastră.</li>
                        <li>**Pip** (managerul de pachete Python) actualizat.</li>
                        <li>**(Opțional, dar recomandat pentru implementare) Docker** instalat.</li>
                        <li>Un **cont Google Cloud Platform (GCP)** activ, cu facturarea configurată.</li>
                        <li>**(Recomandat) Google Cloud SDK (`gcloud` CLI)** instalat și configurat pe mașina locală.</li>
                    </ul>
                </div>

                <div>
                    <h3 class="step-title"><span class="step-counter">2</span>Obținerea Codului Sursă</h3>
                    <p class="text-slate-700 ml-10">Descărcați sau clonați fișierele proiectului (`main.py`, `requirements.txt`, `Dockerfile`, etc.) într-un director local.</p>
                </div>

                <div>
                    <h3 class="step-title"><span class="step-counter">3</span>Mediu Virtual și Dependențe</h3>
                    <p class="text-slate-700 ml-10">Este recomandat să folosiți un mediu virtual Python pentru a izola dependențele proiectului.</p>
                    <h4 class="sub-step-title ml-10">3.1. Creați și Activați Mediul Virtual:</h4>
                    <p class="text-slate-700 ml-10">Navigați în directorul proiectului și rulați:</p>
                    <div class="code-block ml-10">
                        <span class="block">python -m venv venv</span>
                        <span class="block"># Pe Windows:</span>
                        <span class="block">venv\Scripts\activate</span>
                        <span class="block"># Pe macOS/Linux:</span>
                        <span class="block">source venv/bin/activate</span>
                    </div>
                    <h4 class="sub-step-title ml-10">3.2. Instalați Dependențele:</h4>
                    <p class="text-slate-700 ml-10">Cu mediul virtual activat, instalați pachetele necesare:</p>
                    <div class="code-block ml-10">pip install -r requirements.txt</div>
                </div>

                <div>
                    <h3 class="step-title"><span class="step-counter">4</span>Configurarea Proiectului Google Cloud</h3>
                     <h4 class="sub-step-title ml-10">4.1. Creați sau Selectați un Proiect GCP:</h4>
                     <p class="text-slate-700 ml-10">Accesați <a href="https://console.cloud.google.com/" target="_blank" class="text-sky-600 hover:underline">Google Cloud Console</a> și selectați un proiect existent sau creați unul nou. Notați **ID-ul Proiectului (Project ID)**.</p>
                     <h4 class="sub-step-title ml-10">4.2. Activați API-urile Necesare:</h4>
                     <p class="text-slate-700 ml-10">Pentru proiectul selectat, asigurați-vă că următoarele API-uri sunt activate:</p>
                     <ul class="list-disc list-inside space-y-1 text-slate-700 ml-14">
                        <li>**Cloud Firestore API:** Pentru baza de date.</li>
                        <li>**Vertex AI API:** Pentru accesul la modelele Gemini.</li>
                     </ul>
                     <p class="text-slate-700 ml-10">Puteți activa API-urile din secțiunea "APIs & Services" > "Library" a consolei GCP.</p>
                </div>

                <div>
                    <h3 class="step-title"><span class="step-counter">5</span>Configurarea Firestore</h3>
                    <p class="text-slate-700 ml-10">Dacă nu ați făcut-o deja la activarea API-ului:</p>
                    <ul class="list-disc list-inside space-y-1 text-slate-700 ml-14">
                        <li>Navigați la secțiunea Firestore din consola GCP.</li>
                        <li>Creați o bază de date în **Mod Nativ (Native Mode)**.</li>
                        <li>Alegeți o **locație** pentru baza de date (ex: `europe-west1`).</li>
                    </ul>
                </div>
            
                <div>
                    <h3 class="step-title"><span class="step-counter">6</span>Cont de Serviciu și Cheie JSON (Dezvoltare Locală)</h3>
                    <p class="text-slate-700 ml-10">Pentru ca aplicația să se autentifice la GCP de pe mașina locală:</p>
                     <ul class="list-disc list-inside space-y-1 text-slate-700 ml-14">
                        <li>În consola GCP, "IAM & Admin" > "Service Accounts", creați un cont (ex: `cv-processor-dev-sa`).</li>
                        <li>Acordați rolurile: `Cloud Datastore User` și `Vertex AI User`.</li>
                        <li>Generați o cheie JSON pentru acest cont și descărcați-o.</li>
                    </ul>
                    <p class="text-slate-700 ml-10">**Alternativă (ADC):** Rulați `gcloud auth application-default login`.</p>
                </div>

                <div>
                    <h3 class="step-title"><span class="step-counter">7</span>Cheia API Gemini</h3>
                    <p class="text-slate-700 ml-10">Obțineți o cheie API din <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-sky-600 hover:underline">Google AI Studio</a> pentru proiectul GCP.</p>
                </div>

                <div>
                    <h3 class="step-title"><span class="step-counter">8</span>Configurarea Variabilelor de Mediu (`.env`)</h3>
                    <p class="text-slate-700 ml-10">Creați fișierul `.env` în rădăcina proiectului:</p>
                    <div class="code-block ml-10">
                        <span class="block">GEMINI_API_KEY="CHEIA_DVS_API_GEMINI_AICI"</span>
                        <span class="block">WEBHOOK_SECRET="UN_SECRET_PUTERNIC_PENTRU_WEBHOOK"</span>
                        <span class="block">GCP_PROJECT_ID="ID_UL_PROIECTULUI_DVS_GCP"</span>
                        <span class="block"># GOOGLE_APPLICATION_CREDENTIALS="/calea/catre/fisierul_serviciu_cont.json" # (dacă nu folosiți ADC)</span>
                    </div>
                </div>
            
                <div>
                    <h3 class="step-title"><span class="step-counter">9</span>Pornirea Locală a Serverului</h3>
                    <p class="text-slate-700 ml-10">Porniți serverul FastAPI:</p>
                    <div class="code-block ml-10">python main.py</div>
                    <p class="text-slate-700 ml-10">Serverul va rula pe `http://localhost:8000`.</p>
                </div>
            </div>
        </section>

        <section id="usage" class="content-section bg-white p-6 sm:p-8 rounded-lg shadow-xl">
            <h2 class="section-title">Ghid de Utilizare a API-ului</h2>
            <div class="text-content">
                <p class="mb-8">
                    Odată ce sistemul backend este configurat și rulează, puteți interacționa cu el prin API-ul expus. Acest ghid vă arată cum să trimiteți CV-uri pentru procesare și cum să verificați statusul.
                </p>
            </div>
            <div class="space-y-8">
                <div>
                    <h3 class="step-title"><span class="step-counter">1</span>Endpoint Webhook: Procesare CV (`POST /webhook/cv`)</h3>
                    <div class="text-content ml-10">
                        <p>Acesta este endpoint-ul principal pentru a iniția procesarea unui CV. Sistemul acceptă CV-ul fie ca text direct, fie ca un URL către un fișier (PDF, DOCX).</p>
                    </div>
                    <h4 class="sub-step-title ml-10">Securitate:</h4>
                    <p class="text-slate-700 ml-14">Toate cererile către acest endpoint trebuie să includă header-ul HTTP `X-Webhook-Secret`. Valoarea acestui header trebuie să corespundă cu cea setată în variabila de mediu `WEBHOOK_SECRET` a serverului.</p>

                    <h4 class="sub-step-title ml-10">Payload-ul Cererii (Request Body - JSON):</h4>
                    <p class="text-slate-700 ml-14">Corpul cererii trebuie să fie un obiect JSON. Iată câmpurile acceptate:</p>
                    <ul class="list-disc list-inside space-y-1 text-slate-700 ml-18 mb-4">
                        <li>`cv_text` (Opțional, string): Textul integral al CV-ului.</li>
                        <li>`cv_file_payload` (Opțional, obiect): Folosit dacă CV-ul este trimis ca URL.
                            <ul class="list-circle list-inside ml-6">
                                <li>`cv_url` (Obligatoriu dacă `cv_file_payload` este prezent, string): URL-ul valid către fișierul CV.</li>
                                <li>`file_mime_type` (Opțional, string): Tipul MIME al fișierului din URL (ex: "application/pdf", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"). Ajută la procesarea corectă.</li>
                            </ul>
                        </li>
                        <li>`source_candidate_id` (Opțional, string): Un ID unic al candidatului din sistemul sursă (ex: **`candidate_slug` din Recruit CRM**). Esențial pentru a lega datele procesate înapoi la candidatul corect în sistemul extern și pentru idempotență.</li>
                        <li>`idempotency_key` (Opțional, string): O cheie unică furnizată de client pentru a preveni procesările duplicate. Dacă este prezentă, are prioritate față de `source_candidate_id` pentru verificarea idempotenței.</li>
                        <li>`metadata` (Opțional, obiect): Un dicționar pentru a trimite orice metadate suplimentare relevante (ex: `{"job_id": "XYZ123", "source_platform": "RecruitCRM"}`).</li>
                    </ul>
                    <div class="info-note ml-14">
                        <p class="font-semibold">Important:</p>
                        <p class="text-sm">Trebuie furnizat fie câmpul `cv_text`, fie obiectul `cv_file_payload` cu un `cv_url` valid.</p>
                    </div>


                    <h4 class="sub-step-title ml-10">Exemple de Cereri `curl`:</h4>
                    <p class="text-slate-700 font-semibold ml-14">a) Trimitere CV ca text (exemplu specific pentru Recruit CRM):</p>
                    <div class="code-block ml-14">
# Înlocuiți YOUR_WEBHOOK_SECRET și valorile specifice
curl -X POST "http://localhost:8000/webhook/cv" \
-H "Content-Type: application/json" \
-H "X-Webhook-Secret: YOUR_WEBHOOK_SECRET" \
-d '{
  "cv_text": "Nume: Elena Popescu\nEmail: elena.popescu@exemplu.com\nExperienta: ...",
  "source_candidate_id": "recruitcrm-candidate-slug-123xyz",
  "idempotency_key": "webhook-recruitcrm-elena-popescu-001",
  "metadata": {"recruitment_source": "RecruitCRM Event"}
}'
                    </div>
                    <p class="text-slate-700 font-semibold mt-2 ml-14">b) Trimitere CV ca URL (exemplu specific pentru Recruit CRM):</p>
                    <div class="code-block ml-14">
# Înlocuiți YOUR_WEBHOOK_SECRET și valorile specifice
curl -X POST "http://localhost:8000/webhook/cv" \
-H "Content-Type: application/json" \
-H "X-Webhook-Secret: YOUR_WEBHOOK_SECRET" \
-d '{
  "cv_file_payload": {
    "cv_url": "https://url-public-catre-cv-din-recruitcrm.com/cv.pdf",
    "file_mime_type": "application/pdf"
  },
  "source_candidate_id": "recruitcrm-candidate-slug-456abc",
  "metadata": {"job_application_id": "789"}
}'
                    </div>

                    <h4 class="sub-step-title ml-10">Răspuns Așteptat (HTTP 202 Accepted):</h4>
                    <div class="code-block ml-14">
{
  "message": "CV primit și procesarea a fost inițiată în fundal.",
  "processing_id": "uuid-generat-automat-pentru-procesare",
  "status": "pending",
  "status_url": "http://localhost:8000/status/cv/uuid-generat-automat-pentru-procesare"
}
                    </div>
                     <p class="text-slate-700 mt-2 ml-14">Dacă se detectează o cerere duplicat (pe baza `idempotency_key` sau `source_candidate_id`), răspunsul va fi diferit, indicând acest lucru (ex: status `already_received_or_processing`).</p>
                </div>

                <div>
                    <h3 class="step-title"><span class="step-counter">2</span>Endpoint de Verificare a Statusului (`GET /status/cv/{processing_id}`)</h3>
                     <div class="text-content ml-10">
                        <p>Folosiți `processing_id`-ul obținut în răspunsul de la webhook pentru a interoga periodic starea și rezultatele procesării CV-ului.</p>
                    </div>
                    <h4 class="sub-step-title ml-10">Exemplu `curl`:</h4>
                    <div class="code-block ml-14">
# Înlocuiți ID_PROCESARE_PRIMIT cu ID-ul real
curl -X GET "http://localhost:8000/status/cv/ID_PROCESARE_PRIMIT"
                    </div>
                    <h4 class="sub-step-title ml-10">Răspuns Așteptat (HTTP 200 OK):</h4>
                    <p class="text-slate-700 ml-14">Structura răspunsului variază în funcție de starea procesării:</p>
                    <p class="text-slate-700 font-semibold mt-2 ml-14">a) Procesare finalizată cu succes:</p>
                    <div class="code-block ml-14">
{
  "processing_id": "ID_PROCESARE_PRIMIT",
  "status": "completed",
  "received_at_utc": "2024-05-21T10:00:00Z",
  "updated_at_utc": "2024-05-21T10:00:35Z",
  "extracted_data": { /* Datele complete extrase conform CV_EXTRACTION_SCHEMA */ },
  "error_message": null,
  "processing_time_seconds": 35.0
}
                    </div>
                    <p class="text-slate-700 font-semibold mt-2 ml-14">b) Procesare în curs (exemplu):</p>
                    <div class="code-block ml-14">
{
  "processing_id": "ID_PROCESARE_PRIMIT",
  "status": "pending_processing", 
  "received_at_utc": "2024-05-21T10:05:00Z",
  "updated_at_utc": "2024-05-21T10:05:10Z",
  "extracted_data": null,
  "error_message": null,
  "processing_time_seconds": null
}
                    </div>
                     <p class="text-slate-700 font-semibold mt-2 ml-14">c) Eroare în timpul procesării:</p>
                    <div class="code-block ml-14">
{
  "processing_id": "ID_PROCESARE_PRIMIT",
  "status": "error",
  "received_at_utc": "2024-05-21T10:10:00Z",
  "updated_at_utc": "2024-05-21T10:10:05Z",
  "extracted_data": null,
  "error_message": "Descrierea detaliată a erorii întâmpinate.",
  "processing_time_seconds": 5.0
}
                    </div>
                    <p class="text-slate-700 ml-14">Dacă `processing_id` nu este găsit, se va returna un răspuns HTTP 404 Not Found.</p>
                </div>
            </div>
        </section>

        <section id="recruitcrm" class="content-section bg-white p-6 sm:p-8 rounded-lg shadow-xl">
            <h2 class="section-title">Ghid de Integrare cu Recruit CRM</h2>
            <div class="text-content">
            <p class="mb-8">
                Această secțiune descrie pașii și considerațiile pentru integrarea sistemului nostru de procesare a CV-urilor cu platforma Recruit CRM. Scopul este de a automatiza fluxul: primirea unui candidat în Recruit CRM, trimiterea CV-ului către serviciul nostru pentru analiză, și actualizarea profilului candidatului în Recruit CRM cu datele structurate extrase.
            </p>
            </div>
            <div class="note">
                <p class="font-semibold">Notă Importantă:</p>
                <p class="text-sm">Detaliile specifice de configurare (nume de câmpuri, capabilități API, interfața exactă a webhook-urilor) din Recruit CRM pot varia. Consultați întotdeauna documentația oficială Recruit CRM pentru informații precise și actualizate privind API-ul și funcționalitățile de webhook.</p>
            </div>

            <div class="space-y-8">
                <div>
                    <h3 class="step-title"><span class="step-counter">1</span>Trimiterea CV-urilor din Recruit CRM către Procesatorul Inteligent</h3>
                    <p class="text-slate-700 ml-10">Obiectiv: Când un nou candidat este adăugat sau un CV este actualizat în Recruit CRM, informațiile sunt trimise automat către endpoint-ul nostru `/webhook/cv`.</p>
                    
                    <h4 class="sub-step-title ml-10">Metoda Recomandată: Webhooks în Recruit CRM</h4>
                    <ul class="list-disc list-inside space-y-2 text-slate-700 ml-14">
                        <li>**Verificați Capabilitățile Webhook:** Confirmați în documentația Recruit CRM dacă se pot configura webhooks pentru evenimente ca "Candidat Nou Creat" sau "CV Adăugat/Actualizat".</li>
                        <li>**Configurarea Webhook-ului în Recruit CRM:**
                            <ul class="list-circle list-inside ml-6">
                                <li>**URL Endpoint:** Adresa publică a serviciului nostru FastAPI (ex: `https://[URL-UL-DVS-CLOUD-RUN]/webhook/cv`).</li>
                                <li>**Metodă HTTP:** `POST`.</li>
                                <li>**Format Payload:** Ideal, JSON customizabil. Dacă Recruit CRM trimite un format fix, s-ar putea să fie nevoie de un strat intermediar (ex: o funcție Cloud Function simplă sau un serviciu ca Zapier/Make) pentru a transforma payload-ul înainte de a-l trimite API-ului nostru.</li>
                                <li>**Header Securitate:** Configurați Recruit CRM să trimită un header `X-Webhook-Secret` cu valoarea din `.env`.</li>
                            </ul>
                        </li>
                        <li>**Date Esențiale de Trimis în Payload către API-ul nostru:**
                            <ul class="list-circle list-inside ml-6">
                                <li>**`source_candidate_id`**: Trebuie să conțină **`candidate_slug`**-ul unic al candidatului din Recruit CRM. Acesta este crucial pentru a identifica și actualiza corect candidatul ulterior.</li>
                                <li>**`cv_text` SAU `cv_file_payload.cv_url`**:
                                    <ul class="list-disc list-inside ml-6">
                                        <li>Dacă Recruit CRM poate furniza textul CV-ului direct, trimiteți-l în `cv_text`.</li>
                                        <li>Dacă Recruit CRM oferă un URL public și stabil către fișierul CV (PDF, DOCX), trimiteți-l în `cv_file_payload.cv_url`. Furnizați `cv_file_payload.file_mime_type` dacă este cunoscut.</li>
                                    </ul>
                                </li>
                                <li>**`metadata` (Opțional):** Orice alte ID-uri sau informații relevante din Recruit CRM (ex: ID-ul job-ului asociat, sursa candidatului).</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div>
                    <h3 class="step-title"><span class="step-counter">2</span>Procesarea de către Sistemul Nostru</h3>
                    <p class="text-slate-700 ml-10">Sistemul nostru primește webhook-ul, validează cererea, gestionează idempotența (folosind `source_candidate_id` dacă `idempotency_key` nu e dat), descarcă și parsează CV-ul (dacă e URL), extrage datele cu Gemini și le salvează în Firestore. `processing_id`-ul generat este unic pentru această operațiune.</p>
                </div>

                <div>
                    <h3 class="step-title"><span class="step-counter">3</span>Actualizarea Candidatului în Recruit CRM (Backend-to-Backend)</h3>
                    <p class="text-slate-700 ml-10">După ce datele sunt extrase (`status: "completed"` în Firestore), sistemul nostru backend (sau un serviciu adiacent) va iniția un apel API către Recruit CRM pentru a actualiza profilul candidatului.</p>

                    <h4 class="sub-step-title ml-10">Utilizarea API-ului Recruit CRM: `POST /v1/candidates/{candidate_slug}`</h4>
                     <ul class="list-disc list-inside space-y-2 text-slate-700 ml-14">
                        <li>**Identificator:** Se folosește `candidate_slug` (stocat la noi ca `source_candidate_id`) în URL-ul endpoint-ului.</li>
                        <li>**Autentificare:** Cererile necesită un token Bearer (API Token Recruit CRM) în header-ul `Authorization`. Tokenul trebuie stocat securizat (ex: Google Secret Manager).</li>
                        <li>**Format Request Body:** `multipart/form-data`.</li>
                        <li>**Rate Limiting:** API-ul Recruit CRM are limite de rată (ex: 60 cereri/minut). Sistemul backend trebuie să gestioneze aceste limite, posibil printr-o coadă de actualizări și reîncercări cu backoff, monitorizând header-ele `X-RateLimit-Limit` și `X-RateLimit-Remaining`.</li>
                    </ul>

                    <h4 class="sub-step-title ml-10">Descoperirea și Maparea Câmpurilor Custom:</h4>
                    <p class="text-slate-700 ml-14">Pentru o mapare flexibilă și corectă, folosiți endpoint-ul Recruit CRM `GET /v1/custom-fields/candidates` pentru a obține lista câmpurilor custom definite în contul dvs., împreună cu `field_id`, `field_name` și `field_type`.</p>
                    <div class="info-note ml-14">
                        <p class="font-semibold">Strategie de Mapare Dinamică:</p>
                        <p class="text-sm">1. La pornirea serviciului nostru (sau periodic), apelați `GET /v1/custom-fields/candidates` și stocați (ex: în memorie cache sau într-o configurație) o mapare între numele logice ale câmpurilor pe care doriți să le populați (ex: "Sumar AI CV", "Competențe Tehnice AI") și `field_id`-urile returnate de API-ul Recruit CRM pentru `field_name`-urile corespunzătoare.</p>
                        <p class="text-sm">2. Când actualizați un candidat, folosiți această mapare pentru a construi corect secțiunea `custom_fields` din payload-ul `multipart/form-data`.</p>
                    </div>

                    <h4 class="sub-step-title ml-10">Construirea Payload-ului `multipart/form-data` pentru Actualizare:</h4>
                    <p class="text-slate-700 ml-14">Va trebui să construiți corpul cererii `multipart/form-data` cu datele extrase de Gemini, mapate la câmpurile standard și custom din Recruit CRM.</p>
                    <ul class="list-disc list-inside space-y-1 text-slate-700 ml-18">
                        <li>**Câmpuri Standard:** Populați câmpurile standard direct (ex: `email`, `linkedin`, `candidate_summary` cu `overall_assessment_by_llm.key_strengths_summary`, `skill` cu un string concatenat din `skills.technical_skills`).</li>
                        <li>**`custom_fields`:** Pentru fiecare câmp custom pe care doriți să-l actualizați, veți include o pereche `field_id` (din maparea dinamică) și `value`.</li>
                    </ul>
                     <div class="warning-note ml-14">
                        <p class="font-semibold">Formatul `custom_fields` în `multipart/form-data`:</p>
                        <p class="text-sm">Documentația Recruit CRM pentru endpoint-ul `POST /v1/candidates/{candidate_slug}` arată un "Request Sample" cu un payload `multipart/form-data` brut. Este **crucial** să determinați din documentația lor sau prin testare cum trebuie structurat un array de obiecte (cum este `custom_fields` în răspunsul JSON) pentru a fi trimis corect într-o cerere `multipart/form-data`. Opțiuni comune sunt trimiterea ca string JSON sau indexarea fiecărui element (ex: `custom_fields[0][field_id]`, `custom_fields[0][value]`).</p>
                    </div>

                    <h4 class="sub-step-title ml-10">Implementarea Logicii de Actualizare:</h4>
                     <ul class="list-disc list-inside space-y-1 text-slate-700 ml-14">
                        <li>**În `background_cv_processing_task`:** Adăugați logica de apelare a API-ului Recruit CRM după ce datele Gemini sunt extrase cu succes. Folosiți `aiohttp` pentru apeluri asincrone sau rulați `requests` într-un executor de thread-uri.</li>
                        <li>**Serviciu Separat (Recomandat pentru robustețe):** O funcție Cloud Function (sau un alt microserviciu) declanșată de scrierea în Firestore (când `status` devine `completed`). Aceasta decuplează responsabilitățile și permite o gestionare mai bună a reîncercărilor și a limitelor de rată specifice API-ului Recruit CRM.</li>
                     </ul>
                </div>
            </div>
        </section>

        <section id="considerations" class="content-section bg-white p-6 sm:p-8 rounded-lg shadow-xl">
            <h2 class="section-title">Considerații Tehnice Suplimentare</h2>
            <div class="text-content">
                <p class="mb-8">
                    Pentru o implementare robustă în producție, sunt luate în considerare următoarele aspecte:
                </p>
            </div>
             <div class="space-y-6">
                <div>
                    <h4 class="text-lg font-semibold text-sky-600">Securitate</h4>
                    <ul class="list-disc list-inside text-slate-700 ml-4 space-y-1">
                        <li>Utilizarea variabilelor de mediu și a Google Secret Manager pentru stocarea securizată a cheilor API și a altor secrete.</li>
                        <li>Validarea riguroasă a tuturor input-urilor pentru a preveni vulnerabilități (ex: injection).</li>
                        <li>Implementarea de rate limiting pe endpoint-urile publice, dacă este necesar.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="text-lg font-semibold text-sky-600">Scalabilitate</h4>
                    <ul class="list-disc list-inside text-slate-700 ml-4 space-y-1">
                        <li>Arhitectura serverless a Google Cloud Run permite scalarea automată a instanțelor în funcție de volumul de trafic.</li>
                        <li>Procesarea asincronă a task-urilor de lungă durată (cum ar fi extragerea de date) previne blocarea cererilor.</li>
                        <li>Pentru volume extrem de mari, se poate considera decuplarea cu Google Cloud Tasks pentru o mai mare robustețe a cozilor de mesaje.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="text-lg font-semibold text-sky-600">Robustețe și Fiabilitate</h4>
                    <ul class="list-disc list-inside text-slate-700 ml-4 space-y-1">
                        <li>Mecanisme de reîncercare cu backoff exponențial (folosind `tenacity`) pentru apelurile către API-uri externe (Gemini, Recruit CRM).</li>
                        <li>Gestionarea explicită și detaliată a excepțiilor în toate etapele procesării.</li>
                        <li>Idempotența endpoint-ului webhook pentru a preveni procesările duplicate.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="text-lg font-semibold text-sky-600">Logging și Monitorizare</h4>
                    <ul class="list-disc list-inside text-slate-700 ml-4 space-y-1">
                        <li>Logging structurat și detaliat pentru a facilita diagnosticarea problemelor și monitorizarea fluxului de date.</li>
                        <li>Integrarea cu Google Cloud Logging și Cloud Monitoring pentru vizualizarea logurilor, crearea de metrici și configurarea alertelor pentru erori critice sau probleme de performanță.</li>
                    </ul>
                </div>
            </div>
        </section>
    </main>

    <footer class="bg-slate-800 text-slate-300 text-center p-6 mt-12">
        <p>&copy; <span id="currentYear"></span> Sistem de Procesare a CV-urilor. Toate drepturile rezervate.</p>
    </footer>

    <script>
        const CV_EXTRACTION_SCHEMA = {
            "personal_info": {
                "type": "object",
                "description": "Informații de contact și identificare ale candidatului.",
                "properties": {
                    "full_name": {"type": "string", "description": "Numele complet al candidatului, așa cum apare în CV."},
                    "email": {"type": "string", "description": "Adresa de email principală, validată dacă posibil."},
                    "phone_number": {"type": "string", "description": "Numărul de telefon principal, format internațional preferat dacă e clar."},
                    "linkedin_url": {"type": "string", "description": "URL către profilul LinkedIn, dacă este menționat explicit."},
                    "github_url": {"type": "string", "description": "URL către profilul GitHub, dacă este menționat."},
                    "portfolio_url": {"type": "string", "description": "URL către portofoliul personal, dacă este menționat."},
                    "location": {"type": "string", "description": "Orașul și/sau țara de rezidență, dacă sunt menționate."}
                },
                "required": ["full_name"]
            },
            "summary_objective": {
                "type": "string",
                "description": "Sumarul profesional concis, obiectivul de carieră sau secțiunea 'Despre mine' din CV."
            },
            "work_experience": {
                "type": "array",
                "description": "Lista experiențelor profesionale anterioare.",
                "items": {
                    "type": "object",
                    "properties": {
                        "job_title": {"type": "string", "description": "Titlul exact al postului."},
                        "company_name": {"type": "string", "description": "Numele companiei angajatoare."},
                        "company_location": {"type": "string", "description": "Locația companiei (oraș, țară), dacă este specificată."},
                        "start_date": {"type": "string", "description": "Data de început a angajării (ex: 'YYYY-MM', 'Luna Anul')."},
                        "end_date": {"type": "string", "description": "Data de sfârșit (ex: 'YYYY-MM', 'Luna Anul', 'Prezent')."},
                        "duration_months": {"type": "integer", "description": "Durata angajării în luni, dacă poate fi calculată."},
                        "responsibilities_achievements": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "Listă detaliată a responsabilităților, proiectelor și realizărilor cheie."
                        },
                        "technologies_used": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "Tehnologii, unelte sau limbaje de programare specifice utilizate în acest rol."
                        }
                    },
                    "required": ["job_title", "company_name", "start_date"]
                }
            },
            "education": {
                "type": "array",
                "description": "Detalii despre parcursul educațional.",
                "items": {
                    "type": "object",
                    "properties": {
                        "degree_name": {"type": "string", "description": "Numele diplomei sau calificării obținute (ex: Licență, Master, Doctorat)."},
                        "major_field_of_study": {"type": "string", "description": "Specializarea sau domeniul principal de studiu."},
                        "institution_name": {"type": "string", "description": "Numele instituției de învățământ."},
                        "institution_location": {"type": "string", "description": "Locația instituției (oraș, țară), dacă este specificată."},
                        "graduation_date": {"type": "string", "description": "Data absolvirii sau data estimată a absolvirii (ex: 'YYYY-MM', 'Anul')."},
                        "relevant_courses_thesis": {"type": "string", "description": "Cursuri relevante, proiecte academice sau titlul tezei, dacă sunt menționate."}
                    },
                    "required": ["institution_name", "degree_name"]
                }
            },
            "skills": {
                "type": "object",
                "description": "Setul de competențe ale candidatului.",
                "properties": {
                    "technical_skills": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Listă de competențe tehnice (ex: limbaje de programare, framework-uri, baze de date, unelte)."
                    },
                    "soft_skills": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Listă de competențe interpersonale (ex: comunicare, leadership, lucru în echipă)."
                    },
                    "languages": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "language_name": {"type": "string"},
                                "proficiency_level": {"type": "string", "description": "Nivel de cunoaștere (ex: Nativ, Avansat, Mediu, Începător)."}
                            },
                             "required": ["language_name", "proficiency_level"]
                        },
                        "description": "Limbi străine cunoscute și nivelul de competență."
                    }
                }
            },
            "certifications_awards": {
                "type": "array",
                "description": "Certificări, cursuri sau premii obținute.",
                "items": {
                    "type": "object",
                    "properties": {
                        "name": {"type": "string", "description": "Numele certificării, cursului sau premiului."},
                        "issuing_organization": {"type": "string", "description": "Organizația emitentă."},
                        "date_obtained": {"type": "string", "description": "Data obținerii (ex: 'YYYY-MM')."}
                    },
                    "required": ["name"]
                }
            },
            "projects": {
                "type": "array",
                "description": "Proiecte relevante la care a lucrat candidatul.",
                "items": {
                    "type": "object",
                    "properties": {
                        "project_name": {"type": "string"},
                        "description": {"type": "string"},
                        "technologies_used": {"type": "array", "items": {"type": "string"}},
                        "project_url": {"type": "string", "description": "URL către proiect, dacă este disponibil."}
                    },
                    "required": ["project_name", "description"]
                }
            },
            "overall_assessment_by_llm": {
                "type": "object",
                "description": "Evaluare sumară generată de modelul lingvistic mare (LLM).",
                "properties": {
                    "estimated_total_experience_years": {"type": "number", "description": "Numărul total estimat de ani de experiență profesională relevantă, bazat pe datele din CV."},
                    "primary_roles_suitability": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Sugerează 2-3 roluri principale pentru care acest candidat ar putea fi cel mai potrivit, pe baza întregului CV."
                    },
                    "key_strengths_summary": {"type": "string", "description": "Un scurt sumar (2-3 fraze) al principalelor puncte forte ale candidatului."}
                }
            }
        };

        const tabs = document.querySelectorAll('.tab-button');
        const contentSections = document.querySelectorAll('.content-section');
        
        function showTab(tabId, event) { // Added event parameter
            tabs.forEach(tab => {
                if (tab.dataset.tab === tabId) {
                    tab.classList.add('tab-active');
                } else {
                    tab.classList.remove('tab-active');
                }
            });
            contentSections.forEach(section => {
                if (section.id === tabId) {
                    section.classList.add('active');
                } else {
                    section.classList.remove('active');
                }
            });
            if (event && event.type === 'click') { // Only scroll on direct click
                 window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }
        
        const schemaContainer = document.getElementById('cvSchemaContainer');

        function renderSchema(schemaData, container, level = 0) {
            if (!schemaData || typeof schemaData !== 'object') {
                return;
            }

            for (const key in schemaData) {
                if (schemaData.hasOwnProperty(key)) {
                    const item = schemaData[key];
                    const div = document.createElement('div');
                    div.className = `mb-3 p-3 rounded-md ${level === 0 ? 'bg-slate-50 shadow-sm' : 'bg-slate-100 ml-4'}`;
                    
                    const header = document.createElement('div');
                    header.className = 'flex justify-between items-start gap-x-4';

                    const titleContainer = document.createElement('div');
                    titleContainer.className = 'flex-grow min-w-0'; 
                    const title = document.createElement('h4');
                    title.className = `text-md font-semibold ${level === 0 ? 'text-sky-700' : 'text-sky-600'} schema-key`;
                    let titleText = key;
                    if (typeof item === 'object' && item !== null && (item.type === 'object' || item.type === 'array')) {
                        titleText += ' ▼';
                    }
                    title.textContent = titleText;
                    titleContainer.appendChild(title);
                     header.appendChild(titleContainer);

                    if (item && item.description) {
                        const descriptionP = document.createElement('p');
                        descriptionP.className = 'text-xs text-slate-500 mt-0.5 italic text-right flex-shrink-0 max-w-[60%] sm:max-w-[50%] break-words';
                        descriptionP.textContent = item.description;
                        header.appendChild(descriptionP); 
                    }
                    
                    div.appendChild(header);

                    const detailsDiv = document.createElement('div');
                    detailsDiv.className = 'schema-details mt-2 text-sm space-y-1'; 
                    
                    if (item && item.type) {
                         const typeP = document.createElement('p');
                         typeP.innerHTML = `<strong class="text-slate-700 font-medium">Tip:</strong> <span class="bg-sky-100 text-sky-800 px-2 py-0.5 rounded-full text-xs font-medium">${item.type}</span>`;
                         detailsDiv.appendChild(typeP);
                    }
                    if (item && item.required && Array.isArray(item.required) && item.required.length > 0) {
                        const requiredP = document.createElement('p');
                        requiredP.innerHTML = `<strong class="text-slate-700 font-medium">Câmpuri Obligatorii (în obiect):</strong> <span class="text-slate-600">${item.required.join(', ')}</span>`;
                        detailsDiv.appendChild(requiredP);
                    }


                    if (item && item.type === 'object' && item.properties) {
                        renderSchema(item.properties, detailsDiv, level + 1);
                    } else if (item && item.type === 'array' && item.items) {
                        const itemsHeader = document.createElement('p');
                        itemsHeader.innerHTML = `<strong class="text-slate-700 font-medium">Structura Elementelor Array:</strong>`;
                        detailsDiv.appendChild(itemsHeader);
                        if (item.items.type === 'object' && item.items.properties) {
                            renderSchema(item.items.properties, detailsDiv, level + 1);
                        } else if (item.items.type) {
                             const itemTypeP = document.createElement('p');
                             itemTypeP.innerHTML = `<strong class="text-slate-700 font-medium">Tip element:</strong> <span class="bg-sky-100 text-sky-800 px-2 py-0.5 rounded-full text-xs font-medium">${item.items.type}</span>`;
                             if (item.items.description) {
                                itemTypeP.innerHTML += `<span class="italic text-xs text-slate-500 ml-2">(${item.items.description})</span>`;
                             }
                             detailsDiv.appendChild(itemTypeP);
                        }
                    }
                    
                    div.appendChild(detailsDiv);
                    container.appendChild(div);

                    if (item && typeof item === 'object' && (item.type === 'object' || item.type === 'array')) {
                        title.addEventListener('click', (e) => {
                            e.stopPropagation(); 
                            detailsDiv.classList.toggle('open');
                            title.textContent = `${key} ${detailsDiv.classList.contains('open') ? ' ▲' : ' ▼'}`;
                        });
                         if (level === 0) { 
                            detailsDiv.classList.add('open');
                            title.textContent = `${key} ▲`;
                         } else {
                             title.textContent = `${key} ▼`; 
                         }
                    }
                }
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const hash = window.location.hash.substring(1);
            const initialTab = hash || 'overview';
            showTab(initialTab, null); // Pass null for event on initial load

            tabs.forEach(tab => {
                if (tab.dataset.tab === initialTab) {
                    tab.classList.add('tab-active');
                }
                 tab.addEventListener('click', (event) => { 
                    const tabId = tab.dataset.tab;
                    showTab(tabId, event); 
                    history.pushState(null, null, `#${tabId}`);
                });
            });

            if (schemaContainer) {
                renderSchema(CV_EXTRACTION_SCHEMA, schemaContainer);
            }

            window.addEventListener('popstate', () => {
                const hash = window.location.hash.substring(1);
                showTab(hash || 'overview', null); // Pass null for event on popstate
                 tabs.forEach(tab => {
                    if (tab.dataset.tab === (hash || 'overview')) {
                        tab.classList.add('tab-active');
                    } else {
                        tab.classList.remove('tab-active');
                    }
                });
            });
        });


        function toggleDetails(button, elementId) {
            const detailsElement = document.getElementById(elementId);
            if (detailsElement) {
                const isOpen = detailsElement.classList.toggle('open');
                button.classList.toggle('open', isOpen);
            }
        }
        
        document.getElementById('currentYear').textContent = new Date().getFullYear();

    </script>
</body>
</html>
